{"id":"gmail-1","title":"Gmail Extension Quality Improvements","description":"## Context\n\nCode review of the openclaw-gmail extension identified several quality issues affecting the email experience. The extension uses `gog` (a Gmail CLI wrapper) for all Gmail API operations and integrates with OpenClaw's channel plugin system.\n\nKey problems:\n1. **Reply fragmentation**: Agent responses can be split across multiple emails due to block streaming being enabled when global agent defaults set `blockStreamingDefault: \"on\"`. Email should always batch the full response.\n2. **Unnatural quoting**: Quoted replies look robotic — no `<blockquote>` HTML styling, no `>` prefix in plain text, quotes go through markdown parsing which mangles them.\n3. **Missing configurability**: Auto-archive on reply is hardcoded with no way to disable.\n4. **gog coupling**: All Gmail operations spawn child processes via `gog` CLI. Long-term, a library/SDK approach would be cleaner.\n\n## Architecture\n\n- **Extension entry**: `index.ts` → registers `gmailPlugin` via `api.registerChannel()`\n- **Core files**: `channel.ts` (plugin def + gateway), `outbound.ts` (reply sending), `quoting.ts` (thread quote building), `inbound.ts` (email parsing), `monitor.ts` (polling), `sanitize.ts` (inbound HTML-to-plain-text conversion for LLM consumption)\n- **Dispatch**: Uses `runtime.channel.reply.dispatchReplyWithBufferedBlockDispatcher()` at `channel.ts:132`\n- **Outbound flow**: `sendGmailText()` in `outbound.ts` builds body, optionally appends quotes, converts to HTML via `marked` + `sanitize-html` npm package (inline at outbound.ts:147-153), sends via `gog gmail send`\n- **Quoting flow**: `fetchQuotedContext()` in `quoting.ts` fetches thread via `gog gmail thread get`, extracts last non-self message, formats as `On <date>, <sender> wrote:\\n\\n<body>`\n\n## Key Files\n\n- `src/channel.ts` — Plugin definition, capabilities, gateway, dispatch (365 lines)\n- `src/outbound.ts` — Reply composition and sending (176 lines)\n- `src/quoting.ts` — Thread quote building (231 lines)\n- `src/sanitize.ts` — Inbound HTML-to-plain-text conversion (strips tracking pixels, footers, signatures) (166 lines)\n- `src/outbound-check.ts` — Thread recipient validation (234 lines)\n- `src/monitor.ts` — Polling-based email sync (473 lines)\n- `src/config.ts` — Zod schemas for GmailConfig and GmailAccountSchema (33 lines)\n\n## OpenClaw Core Integration Points\n\n- Block streaming controlled by `replyOptions.disableBlockStreaming` passed to dispatcher\n- `textChunkLimit: 8000` set on plugin outbound config (`channel.ts:228`)\n- Agent prompt hints at `channel.ts:277-294` guide LLM behavior for email context\n- Core default chunk limit is 4000 chars; plugin's 8000 may not propagate to block streaming resolution for extension channels\n\n## Config Key Convention\n\nOpenClaw channels use the plugin ID as the config key under `cfg.channels`. The convention is `cfg.channels?.gmail`. Note: there is a pre-existing inconsistency in the codebase where `outbound.ts:49` reads config as `cfg.channels?.gmail` but `channel.ts:214` writes with `sectionKey: \"openclaw-gmail\"`. Follow the existing read pattern (`cfg.channels?.gmail`) for new config access.\n\n## Build & Test\n\n- No build script — the project is loaded as raw `.ts` by the OpenClaw runtime via a loader (Jiti)\n- `package.json` `main` field is `index.ts` (not compiled JS)\n- `peerDependencies` requires `openclaw >= 2026.1.0`\n- Test files exist: `src/sanitize.test.ts`, `src/outbound-check.test.ts` (run via the OpenClaw test harness or directly with a compatible test runner)\n- No standalone `npm test` script — verify changes by inspecting TypeScript types and running tests via the host project\n\n## Recommended Execution Order\n\n1. **gmail-1.1** (block streaming) — isolated to `channel.ts`, no overlap\n2. **gmail-1.3** (auto-archive config) — small, surgical change in `outbound.ts`\n3. **gmail-1.2** (quoting overhaul) — large restructure of `outbound.ts` and `quoting.ts`, do last to avoid line-number drift","status":"closed","priority":1,"issue_type":"epic","owner":"mcinteerj@gmail.com","created_at":"2026-02-22T12:29:32.106228777+13:00","created_by":"Jake McInteer","updated_at":"2026-02-22T13:20:24.314953506+13:00","closed_at":"2026-02-22T13:20:24.314953506+13:00","close_reason":"All child tasks complete. Quality improvements shipped, googleapis migration tracked under gmail-2."}
{"id":"gmail-1.1","title":"Disable block streaming for email delivery","description":"## Problem\n\nWhen a user's OpenClaw config has `agents.defaults.blockStreamingDefault: \"on\"` (common for chat channels), Gmail sessions also stream block replies. Each flushed block triggers a separate `deliver()` call, which sends a **separate email**. This causes agent responses to be fragmented across multiple emails.\n\nThe block streaming coalescer has a 1-second idle timeout — if the agent pauses for >1s during generation (thinking, tool calls), the buffer flushes and sends what it has as a separate email.\n\n## Root Cause\n\n`channel.ts:132-142` calls `dispatchReplyWithBufferedBlockDispatcher` without passing `replyOptions.disableBlockStreaming`. Block streaming resolution in OpenClaw core (`get-reply-directives.ts:358-372`) checks:\n1. `opts.disableBlockStreaming` (not set by gmail)\n2. `agentCfg.blockStreamingDefault` (user's global setting)\n3. Falls back to \"off\"\n\nIf the user has streaming enabled globally, gmail inherits it.\n\n## Fix\n\nIn `src/channel.ts`, the dispatcher call at lines 132-142 currently looks like:\n\n```typescript\nawait runtime.channel.reply.dispatchReplyWithBufferedBlockDispatcher({\n  ctx: ctxPayload,\n  cfg,\n  dispatcherOptions: {\n    deliver,\n    humanDelay,\n    onError: (err: unknown, info: { kind: string }) => {\n      log?.error(`[gmail][${requestId}] ${info.kind} reply failed: ${String(err)}`);\n    },\n  },\n});\n```\n\nAdd `replyOptions` as a **sibling key** to `ctx`, `cfg`, and `dispatcherOptions` in the same object:\n\n```typescript\nawait runtime.channel.reply.dispatchReplyWithBufferedBlockDispatcher({\n  ctx: ctxPayload,\n  cfg,\n  dispatcherOptions: {\n    deliver,\n    humanDelay,\n    onError: (err: unknown, info: { kind: string }) => {\n      log?.error(`[gmail][${requestId}] ${info.kind} reply failed: ${String(err)}`);\n    },\n  },\n  replyOptions: {\n    disableBlockStreaming:\n      typeof gmailCfg?.blockStreaming === \"boolean\"\n        ? !gmailCfg.blockStreaming\n        : true,  // Default: disabled for email\n  },\n});\n```\n\nNote: `gmailCfg` is not currently available in the `dispatchGmailMessage` function scope. You need to resolve it from `cfg` the same way `outbound.ts:49` does:\n\n```typescript\nconst gmailCfg = cfg.channels?.gmail as GmailConfig | undefined;\n```\n\nImport `GmailConfig` from `./config.js` (already exported from that module).\n\n### Config schema updates\n\nAdd `blockStreaming` to the Zod schema in `src/config.ts` (`GmailConfigSchema` or top-level channel config) as an optional boolean.\n\nAlso add it to the JSON schema in `channel.ts` under `configSchema.schema.properties`:\n\n```typescript\nblockStreaming: { type: \"boolean\", default: false },\n```\n\n### Config key note\n\nThe extension reads config from `cfg.channels?.gmail` (see `outbound.ts:49`). Use this same path for the `blockStreaming` config. There is a pre-existing inconsistency where `channel.ts:214` writes with `sectionKey: \"openclaw-gmail\"` — do not change that; just follow the existing read pattern.\n\nThis approach follows the WhatsApp pattern in OpenClaw core (`web/auto-reply/monitor/process-message.ts:416-422`).\n\n## Testing\n\n1. Set `agents.defaults.blockStreamingDefault: \"on\"` in OpenClaw config\n2. Send an email that triggers a long agent response (e.g., ask for a detailed explanation)\n3. Verify the response arrives as a single email, not multiple\n4. Set `channels.gmail.blockStreaming: true` in config and verify streaming is re-enabled\n5. Remove both settings and verify default behavior (no streaming)\n\n## Acceptance Criteria\n\n- [ ] Gmail replies always arrive as a single email by default\n- [ ] `channels.gmail.blockStreaming` config option respected (boolean, default false)\n- [ ] No change to behavior when block streaming is globally off (already works correctly)\n- [ ] `blockStreaming` added to Zod schema in `config.ts` and JSON schema in `channel.ts`\n","status":"closed","priority":1,"issue_type":"task","owner":"mcinteerj@gmail.com","created_at":"2026-02-22T12:29:50.680569023+13:00","created_by":"Jake McInteer","updated_at":"2026-02-22T13:20:16.421488829+13:00","closed_at":"2026-02-22T13:20:16.421488829+13:00","close_reason":"Implemented: replyOptions.disableBlockStreaming added to dispatcher call","labels":["outbound","block-streaming","P0"],"dependencies":[{"issue_id":"gmail-1.1","depends_on_id":"gmail-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z"}]}
{"id":"gmail-1.2","title":"Implement native Gmail-style HTML blockquote quoting","description":"## Problem\n\nQuoted replies in agent emails look robotic and unnatural compared to native Gmail quoting. Two issues:\n\n1. **No visual quote styling**: Quotes are plain text appended to the reply body with just a `On <date>, <sender> wrote:` header. No `<blockquote>` HTML, no border-left styling, no `gmail_quote` CSS class. Recipients see the quoted text as indistinguishable from the reply itself.\n\n2. **Quotes go through markdown parsing**: In `outbound.ts:135`, the quote is concatenated to the reply text BEFORE `marked.parse()` runs at line 146. This means the quoted email content gets markdown-interpreted — `*asterisks*` become italic, `#` becomes headings, URLs get auto-linked differently, etc.\n\n### Current flow (outbound.ts:80-159)\n\n```\nreply text + \"\\n\\n\" + quoted text  ->  marked.parse()  ->  sanitize-html  ->  gog send --body-html\n```\n\n### Desired flow\n\n```\nreply text  ->  marked.parse()  ->  sanitize-html  ->  append Gmail-style <blockquote> HTML  ->  gog send --body-html\n```\n\n## Fix\n\n### A. Restructure outbound.ts\n\nSeparate reply body processing from quote construction. The key change is in the `sendGmailText()` function:\n\n1. Parse **only the reply text** through `marked` + `sanitize-html` to get reply HTML (currently at lines 144-159)\n2. Build quote HTML separately using proper Gmail structure:\n   ```html\n   <div class=\"gmail_quote\">\n     <div dir=\"ltr\" class=\"gmail_attr\">On Mon, Feb 22, 2026 at 2:15 PM, John Doe wrote:</div>\n     <blockquote class=\"gmail_quote\" style=\"margin:0px 0px 0px 0.8ex;border-left:1px solid rgb(204,204,204);padding-left:1ex\">\n       [original message HTML, sanitized]\n     </blockquote>\n   </div>\n   ```\n3. Concatenate: `replyHtml + quoteHtml` for `--body-html`\n4. For `--body` (plain text): `reply text + \"\\n\\n\" + \"On <date>, <sender> wrote:\\n\" + \"> \" prefixed quote lines`\n\nCurrently the quote text and reply text are concatenated at line 135 (`body = \\`${text}\\n\\n${quotedContext}\\``), then the combined string goes through `marked.parse()` at line 146. The restructured flow should NOT concatenate them before markdown parsing.\n\n### B. Update quoting.ts — return structured data\n\n`fetchQuotedContext()` (lines 219-230) currently returns a pre-formatted string. Change it to return structured data so `outbound.ts` can build HTML and plain text separately:\n\n```typescript\nexport interface QuotedContent {\n  header: string;        // \"On Mon, Feb 22, 2026 at 2:15 PM, John Doe wrote:\"\n  bodyHtml: string;      // Sanitized HTML from original message\n  bodyPlain: string;     // Plain text from original message\n}\n```\n\n**There is exactly one call site** for `fetchQuotedContext`: `outbound.ts:129-136`. Update it to consume the new `QuotedContent` return type.\n\n### C. Update quoting.ts — extract HTML body\n\nThe current `extractBody()` function (lines 55-68) only extracts `text/plain` MIME parts. Add a new `extractHtmlBody()` that extracts the `text/html` MIME part for richer quotes:\n\n```typescript\nfunction extractHtmlBody(msg: GogRawMessage): string {\n  if (msg.payload.parts) {\n    const htmlPart = msg.payload.parts.find((p) => p.mimeType === \"text/html\");\n    if (htmlPart?.body?.data) {\n      return Buffer.from(htmlPart.body.data, \"base64\").toString(\"utf-8\");\n    }\n  }\n  if (msg.payload.body?.data) {\n    return Buffer.from(msg.payload.body.data, \"base64\").toString(\"utf-8\");\n  }\n  return \"\";\n}\n```\n\n### D. Sanitize HTML quotes before embedding\n\nThe HTML from the original message needs sanitization before embedding in the blockquote (strip scripts, tracking pixels, event handlers). Use the `sanitize-html` npm package (already a dependency — see `outbound.ts:3`) with permissive tag settings to preserve formatting (bold, links, lists, etc.) while removing dangerous content.\n\nNote: `src/sanitize.ts` is an **inbound** HTML-to-plain-text converter (for LLM consumption). It is NOT for HTML sanitization. Do not modify it for this task. Use the `sanitize-html` npm package directly for quote HTML sanitization.\n\n### E. Update quoteBody() for plain text\n\nThe `quoteBody()` function at `quoting.ts:181-183` is currently a no-op passthrough:\n```typescript\nfunction quoteBody(body: string): string {\n  return body;\n}\n```\n\nUpdate it to add `> ` prefix to each line for proper plain text quoting.\n\n## Files to modify\n\n- `src/quoting.ts` — Return structured `QuotedContent`, add `extractHtmlBody()`, fix `quoteBody()` for plain text\n- `src/outbound.ts` — Restructure to build HTML and plain text separately, append blockquote HTML after markdown parsing\n\n## Build & Test\n\nThis project has no standalone build script — it is loaded as raw `.ts` by the OpenClaw runtime via Jiti. There is no `npm test` command. Verify changes by:\n- Checking TypeScript types are correct (no compile errors)\n- Manually testing by sending an email reply through the OpenClaw runtime\n- Visually confirming the quote renders with Gmail-native blockquote styling in a real email client\n\n## Acceptance Criteria\n\n- [ ] Quoted replies render with Gmail-native `<blockquote>` styling (border-left, indentation)\n- [ ] Original message formatting (bold, links, lists) preserved in HTML quotes\n- [ ] Plain text `--body` uses `> ` prefix quoting\n- [ ] Quote text is NOT processed through markdown parser\n- [ ] Existing `includeQuotedReplies` config toggle (outbound.ts:67-69) still works\n- [ ] Single call site at `outbound.ts:129` updated to handle new `QuotedContent` return type\n- [ ] Visual verification: send a test reply and confirm quote looks native in Gmail/Outlook (manual test)\n","status":"closed","priority":1,"issue_type":"task","owner":"mcinteerj@gmail.com","created_at":"2026-02-22T12:30:15.875489376+13:00","created_by":"Jake McInteer","updated_at":"2026-02-22T13:20:17.45957889+13:00","closed_at":"2026-02-22T13:20:17.45957889+13:00","close_reason":"Implemented: Gmail-style blockquote quoting with structured QuotedContent","labels":["quoting","outbound","P0"],"dependencies":[{"issue_id":"gmail-1.2","depends_on_id":"gmail-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z"}]}
{"id":"gmail-1.3","title":"Make auto-archive on reply configurable","description":"## Problem\n\nIn `outbound.ts:163-173`, every thread reply automatically removes the `INBOX` label (archives the thread). This is hardcoded with no way to disable it.\n\n```typescript\nif (isThread) {\n  const archiveArgs = [\"gmail\", \"labels\", \"modify\", toValue];\n  if (account.email) archiveArgs.push(\"--account\", account.email);\n  archiveArgs.push(\"--remove\", \"INBOX\");\n  spawnGog(archiveArgs).catch((err) => {\n    console.error(`Failed to archive thread ${toValue}: ${err.message}`);\n  });\n}\n```\n\nSome users may want threads to remain in their inbox after the agent replies, especially for oversight/review workflows.\n\n## Fix\n\n### 1. Add config resolution in `outbound.ts`\n\nUse the existing `gmailCfg` (line 49) and `accountCfg` (line 66) variables already in scope within `sendGmailText()`:\n\n```typescript\n// These already exist in sendGmailText():\n// outbound.ts:49 -> const gmailCfg = cfg.channels?.gmail as GmailConfig | undefined;\n// outbound.ts:66 -> const accountCfg = gmailCfg?.accounts?.[accountId || \"default\"];\n\n// Add after the existing config resolution block (~line 78):\nconst archiveOnReply = accountCfg?.archiveOnReply\n  ?? gmailCfg?.defaults?.archiveOnReply\n  ?? true;\n```\n\nThen wrap the archive block at lines 163-173:\n\n```typescript\nif (isThread && archiveOnReply) {\n  // ... existing archive logic unchanged\n}\n```\n\n### 2. Update Zod schema in `src/config.ts`\n\nAdd `archiveOnReply` as an optional boolean to:\n- The account schema (per-account override)\n- The defaults schema (global default)\n\n### 3. Update JSON schema in `src/channel.ts`\n\nAdd to `configSchema.schema.properties.accounts.additionalProperties.properties`:\n```typescript\narchiveOnReply: { type: \"boolean\", default: true },\n```\n\nAnd to `configSchema.schema.properties.defaults.properties`:\n```typescript\narchiveOnReply: { type: \"boolean\", default: true },\n```\n\n## Config key note\n\nConfig is read from `cfg.channels?.gmail` (see `outbound.ts:49`). Follow this existing pattern. There is a pre-existing inconsistency where `channel.ts:214` writes with `sectionKey: \"openclaw-gmail\"` — do not change that.\n\n## Files to modify\n\n- `src/outbound.ts` — Add config check before archive (use existing `gmailCfg` at line 49 and `accountCfg` at line 66)\n- `src/config.ts` — Add `archiveOnReply` to Zod schema\n- `src/channel.ts` — Add `archiveOnReply` to JSON configSchema\n\n## Acceptance Criteria\n\n- [ ] `archiveOnReply: false` in account or defaults config prevents archiving\n- [ ] Default behavior unchanged (archives on reply when not configured)\n- [ ] Config resolution follows existing pattern: account -> defaults -> true\n- [ ] Both Zod schema (`config.ts`) and JSON schema (`channel.ts`) updated\n","status":"closed","priority":2,"issue_type":"feature","owner":"mcinteerj@gmail.com","created_at":"2026-02-22T12:30:30.217843004+13:00","created_by":"Jake McInteer","updated_at":"2026-02-22T13:20:18.541730523+13:00","closed_at":"2026-02-22T13:20:18.541730523+13:00","close_reason":"Implemented: archiveOnReply config at account and defaults level","labels":["outbound","config","P1"],"dependencies":[{"issue_id":"gmail-1.3","depends_on_id":"gmail-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z"}]}
{"id":"gmail-1.4","title":"Evaluate migrating from gog CLI to googleapis library","description":"## Context\n\nAll Gmail API operations in the extension spawn `gog` (a Go CLI tool by steipete/gogcli) as child processes. This works but has overhead: ~50-200ms per-call (process spawn + Go binary startup), string-based error handling, no connection reuse, and fragile child process lifecycle management.\n\n## Research Findings\n\n### gog\n\n- Go CLI tool at `/home/jakemc/bin/gog` (v0.9.0), installed via Homebrew\n- **No library/SDK mode** — CLI-only, no importable Go library or Node.js SDK\n- Active maintenance (GitHub: steipete/gogcli, 78 open issues)\n- OAuth tokens stored in encrypted JWE keyring at `~/.config/gogcli/keyring/`\n- OAuth client_id/client_secret stored in plaintext at `~/.config/gogcli/credentials.json`\n- 15+ spawn calls across the extension codebase for different operations\n\n### googleapis (official Google API client for Node.js)\n\n- npm package `googleapis` — millions of weekly downloads, Google-maintained\n- Full TypeScript types, 1:1 mapping to Gmail REST API\n- Auth via `google-auth-library` with automatic token refresh\n- **Can reuse gog's existing OAuth client_id/client_secret** from `credentials.json`\n- Would need a one-time re-authorization to get a new refresh_token (same GCP project, same consent screen)\n- In-process calls, HTTP/2 keep-alive, typed exceptions, proper async\n\n### Comparison\n\n| Metric | gog CLI | googleapis |\n|--------|---------|------------|\n| Per-call overhead | ~50-200ms | ~0ms |\n| Error handling | Parse stderr | Typed exceptions |\n| Connection reuse | None | HTTP/2 keep-alive |\n| MIME construction | Handled by gog | Manual (use mailcomposer/nodemailer builder) |\n| Watch/push server | Built-in `gog gmail watch serve` | Need own HTTP endpoint (gateway already exists) |\n| Auth flow | `gog auth add` | Implement OAuth flow or extract existing token |\n\n### Migration Phases\n\n1. **Phase 1 (low effort)**: Replace simple spawn calls in extension (send, thread get, search, labels). ~2-4 hours per command.\n2. **Phase 2 (medium effort)**: Replace `gog gmail watch serve` with direct `googleapis` + gateway HTTP endpoint. ~1-2 days. Eliminates fragile child process lifecycle management.\n3. **Phase 3 (auth)**: Reuse existing client_id/secret, implement one-time OAuth flow for new refresh_token, store in OpenClaw config. ~2-4 hours.\n\n### Key Risk\n\nMIME message construction for send/reply is non-trivial. gog handles RFC 2822 formatting internally. With googleapis, need to construct MIME messages ourselves (libraries like `mailcomposer` help but add complexity).\n\n### Impact on Users\n\n- **If gog stays**: Users keep existing auth setup, no migration needed\n- **If googleapis replaces gog**: Users need a one-time re-authorization (browser popup, same GCP project). The painful OAuth app setup (GCP project, consent screen, scopes) is NOT repeated — only the token exchange.\n\n## Decision Needed\n\nWhether to migrate and on what timeline. Current recommendation: keep gog for now, track googleapis migration as a future improvement. The extension's current issues (block streaming, quoting) are independent of the transport layer.\n\n## Status\n\nResearch complete. No action required until a decision is made.","status":"closed","priority":3,"issue_type":"decision","owner":"mcinteerj@gmail.com","created_at":"2026-02-22T12:32:47.226802977+13:00","created_by":"Jake McInteer","updated_at":"2026-02-22T13:20:23.118113305+13:00","closed_at":"2026-02-22T13:20:23.118113305+13:00","close_reason":"Decision: proceed with googleapis migration. Research complete, beads created under gmail-2.","labels":["gog","architecture","research"],"dependencies":[{"issue_id":"gmail-1.4","depends_on_id":"gmail-1","type":"parent-child","created_at":"0001-01-01T00:00:00Z"}]}
{"id":"gmail-2","title":"Migrate from gog CLI to googleapis","description":"## Context\n\nThe openclaw-gmail extension currently spawns the `gog` Go CLI tool for all Gmail API operations (~15+ spawn calls across 5 files). This works but has overhead: ~50-200ms per call (process spawn + Go startup), string-based error handling, no connection reuse, and fragile child process lifecycle management.\n\nDecision made to migrate to `@googleapis/gmail` npm package (standalone, ~1.2 MB) + `google-auth-library` for OAuth + `nodemailer` MailComposer for MIME construction.\n\n## Architecture\n\n### New Dependencies\n- `@googleapis/gmail` — Standalone Gmail API client (~1.2 MB, NOT the full 200 MB `googleapis` package)\n- `google-auth-library` — OAuth2 with automatic token refresh (already a transitive dep)\n- `nodemailer` — MailComposer for RFC 2822 MIME construction\n\n### Transport Abstraction\nIntroduce a `GmailClient` interface with two implementations:\n- `GogGmailClient` — Current implementation wrapping gog CLI spawn calls\n- `ApiGmailClient` — New implementation using @googleapis/gmail directly\n\nPer-account `backend` config selects which client to use. Default: `\"api\"` for new users, existing users keep gog until they opt in.\n\n### Auth Strategy\n- Users provide their own GCP OAuth client_id/client_secret (same as gog requires today)\n- For existing gog users: read client_id/secret from `~/.config/gogcli/credentials.json`, do one-time re-auth for our own refresh_token\n- For new users: guide through GCP OAuth setup, then standard browser OAuth flow\n- Store refresh_token in OpenClaw config (encrypted section) or dedicated token file\n- JWE keyring extraction NOT pursued (too fragile, OS-keychain-dependent)\n\n### Files with gog spawn calls to replace\n- `src/outbound.ts` — `spawnGog()`: gmail send, labels modify (archive)\n- `src/monitor.ts` — `runGog()`: messages search, get, labels modify/list/create, thread modify, search, attachment\n- `src/quoting.ts` — `fetchThread()`: gmail thread get --full\n- `src/outbound-check.ts` — `fetchThreadData()`: gmail thread get\n- `src/onboarding.ts` — gog version check, auth list/add, settings sendas list\n- `src/channel.ts` — Agent prompt hint referencing gog attachment command\n\n## Recommended Execution Order\n\n1. **gmail-2.1** (GmailClient interface + gog backend) — Extract interface, no behavior change\n2. **gmail-2.2** (OAuth + token management) — Auth flow, credential storage, gog cred reuse\n3. **gmail-2.3** (API client: read ops) — Implement thread get, message get/search/list, labels, attachments\n4. **gmail-2.4** (API client: write ops + MIME) — Implement send, reply, reply-all with MailComposer, label modify\n5. **gmail-2.5** (Onboarding overhaul) — Update onboarding flow for both new and existing gog users","status":"open","priority":1,"issue_type":"epic","owner":"mcinteerj@gmail.com","created_at":"2026-02-22T13:20:50.144705221+13:00","created_by":"Jake McInteer","updated_at":"2026-02-22T13:20:50.144705221+13:00","labels":["architecture","googleapis","migration"]}
{"id":"gmail-2.1","title":"Extract GmailClient interface and wrap gog in GogGmailClient","description":"## Goal\n\nCreate a transport abstraction layer so the rest of the codebase talks to a typed interface rather than spawning gog directly. This is a pure refactor — no behavior change, no new dependencies.\n\n## Design\n\n### Interface: `src/gmail-client.ts`\n\n```typescript\nexport interface GmailClient {\n  send(opts: {\n    from: string;\n    to: string;\n    cc?: string;\n    subject: string;\n    textBody: string;\n    htmlBody: string;\n    threadId?: string;\n    inReplyTo?: string;\n    references?: string;\n    replyAll?: boolean;\n  }): Promise<{ messageId: string }>;\n\n  getThread(threadId: string, opts?: { full?: boolean }): Promise<ThreadResponse | null>;\n  getMessage(messageId: string): Promise<GogRawMessage | null>;\n  searchMessages(query: string, maxResults?: number): Promise<{ id: string; threadId: string }[]>;\n\n  modifyLabels(id: string, opts: { add?: string[]; remove?: string[] }): Promise<void>;\n  modifyThreadLabels(threadId: string, opts: { add?: string[]; remove?: string[] }): Promise<void>;\n  listLabels(): Promise<{ id: string; name: string }[]>;\n  createLabel(name: string): Promise<void>;\n\n  getAttachment(messageId: string, attachmentId: string): Promise<Buffer>;\n  getSendAs(): Promise<{ displayName?: string; email: string; isPrimary?: boolean }[]>;\n}\n```\n\n### Implementation: `src/gog-client.ts`\n\nMove the existing `spawnGog()` from `outbound.ts` and `runGog()` from `monitor.ts` into a `GogGmailClient` class implementing `GmailClient`. The class takes `accountEmail` in constructor.\n\n### Factory: `src/gmail-client.ts`\n\n```typescript\nexport function createGmailClient(account: ResolvedGmailAccount): GmailClient {\n  // For now, always return GogGmailClient\n  // gmail-2.3/2.4 will add ApiGmailClient and backend config switching\n  return new GogGmailClient(account.email);\n}\n```\n\n### Config addition\n\nAdd `backend?: \"gog\" | \"api\"` to `GmailAccountSchema` in `config.ts` and to the JSON schema in `channel.ts`. Default: `\"gog\"` (for backwards compatibility during migration; will flip to `\"api\"` once the API client is complete).\n\n## Files to modify\n\n- **Create** `src/gmail-client.ts` — Interface + factory\n- **Create** `src/gog-client.ts` — GogGmailClient extracting spawn logic from outbound.ts, monitor.ts, quoting.ts, outbound-check.ts\n- **Modify** `src/outbound.ts` — Replace direct `spawnGog()` calls with `client.send()` and `client.modifyLabels()`\n- **Modify** `src/monitor.ts` — Replace `runGog()` calls with client methods\n- **Modify** `src/quoting.ts` — Replace `fetchThread()` with `client.getThread()`\n- **Modify** `src/outbound-check.ts` — Replace `fetchThreadData()` with `client.getThread()`\n- **Modify** `src/onboarding.ts` — Keep gog-specific checks for now (onboarding overhauled in gmail-2.5)\n- **Modify** `src/config.ts` — Add `backend` to account schema\n- **Modify** `src/channel.ts` — Add `backend` to JSON schema, update agent prompt to not reference gog directly\n\n## Acceptance Criteria\n\n- [ ] `GmailClient` interface defined with typed methods for all operations\n- [ ] `GogGmailClient` implements the interface using existing gog spawn logic\n- [ ] All 5 source files with gog spawns now go through the client (except onboarding.ts)\n- [ ] `createGmailClient()` factory exists and returns GogGmailClient\n- [ ] `backend` config option added to schemas (default: \"gog\")\n- [ ] Zero behavior change — all existing functionality works identically\n- [ ] No new npm dependencies in this bead","status":"open","priority":1,"issue_type":"task","owner":"mcinteerj@gmail.com","created_at":"2026-02-22T13:21:12.169784128+13:00","created_by":"Jake McInteer","updated_at":"2026-02-22T13:21:12.169784128+13:00","labels":["architecture","refactor"],"dependencies":[{"issue_id":"gmail-2.1","depends_on_id":"gmail-2","type":"parent-child","created_at":"0001-01-01T00:00:00Z"}]}
{"id":"gmail-2.2","title":"Implement OAuth2 flow and token management","description":"## Goal\n\nImplement the OAuth2 authorization flow and token storage needed for the API client. This bead adds the auth infrastructure without yet implementing any Gmail API calls.\n\n## Auth Flow\n\n### OAuth2 with google-auth-library\n\n```typescript\nimport { OAuth2Client } from 'google-auth-library';\n\nconst oauth2Client = new OAuth2Client(CLIENT_ID, CLIENT_SECRET, REDIRECT_URI);\n\n// Generate auth URL for browser consent\nconst authUrl = oauth2Client.generateAuthUrl({\n  access_type: 'offline',\n  scope: ['https://mail.google.com/'],\n  prompt: 'consent', // Force refresh_token generation\n});\n\n// Exchange authorization code for tokens\nconst { tokens } = await oauth2Client.getToken(authorizationCode);\n// tokens.refresh_token is what we store long-term\n// tokens.access_token auto-refreshes via the library\n```\n\n### Credential Sources (in priority order)\n\n1. **OpenClaw config** — `channels.gmail.accounts.<email>.oauth.clientId`, `.clientSecret`, `.refreshToken`\n2. **gog credentials file** — Read `client_id`/`client_secret` from `~/.config/gogcli/credentials.json` (plain JSON, trivially parseable)\n3. **User prompt** — Ask for client_id/client_secret during onboarding if neither source exists\n\n### Implementation: `src/auth.ts`\n\n```typescript\nexport interface OAuthCredentials {\n  clientId: string;\n  clientSecret: string;\n  refreshToken: string;\n}\n\n// Resolve credentials from config or gog\nexport function resolveOAuthCredentials(\n  accountEmail: string,\n  cfg: OpenClawConfig\n): OAuthCredentials | null;\n\n// Read gog's credentials.json\nexport function readGogCredentials(): { clientId: string; clientSecret: string } | null;\n\n// Create authenticated OAuth2Client\nexport function createOAuth2Client(creds: OAuthCredentials): OAuth2Client;\n\n// Run browser-based OAuth flow, return refresh_token\nexport async function runOAuthFlow(\n  clientId: string,\n  clientSecret: string,\n  opts?: { port?: number }\n): Promise<string>;\n```\n\n### OAuth Flow Mechanics\n\nFor the browser OAuth flow, use a local HTTP server on a random port as the redirect URI:\n\n1. Start local HTTP server on `http://localhost:<port>`\n2. Open browser to Google consent URL with `redirect_uri=http://localhost:<port>/callback`\n3. User authorizes, Google redirects to localhost with `?code=...`\n4. Exchange code for tokens, extract refresh_token\n5. Shut down local server\n\nThe redirect URI must be registered in the user's GCP OAuth client as an \"authorized redirect URI.\" For installed/desktop apps, `http://localhost` is auto-allowed by Google.\n\n### Token Storage\n\nStore the refresh_token in the OpenClaw config under:\n```json\n{\n  \"channels\": {\n    \"gmail\": {\n      \"accounts\": {\n        \"user@gmail.com\": {\n          \"oauth\": {\n            \"clientId\": \"...\",\n            \"clientSecret\": \"...\",\n            \"refreshToken\": \"...\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nUpdate Zod schema in `config.ts` to include `oauth` object on the account schema.\n\n### gog Credential Reuse\n\n`~/.config/gogcli/credentials.json` contains:\n```json\n{\n  \"client_id\": \"499832074112-....apps.googleusercontent.com\",\n  \"client_secret\": \"GOCSPX-...\"\n}\n```\n\nWe can read this to pre-fill client_id/client_secret, but still need our own refresh_token via a one-time re-auth. Since the user already consented to this OAuth client, Google may auto-approve without showing the consent screen again.\n\n**Do NOT attempt to extract tokens from gog's JWE keyring** (`~/.config/gogcli/keyring/`) — it uses PBES2-HS256+A128KW encryption with an OS-keychain-stored password. Too fragile and OS-dependent.\n\n## New Dependencies\n\n- `google-auth-library` (already a transitive dep of gaxios which is already in the tree)\n- `open` (to open browser for OAuth — or use child_process xdg-open/open)\n\n## Files to create/modify\n\n- **Create** `src/auth.ts` — OAuth2 flow, credential resolution, gog cred reading\n- **Modify** `src/config.ts` — Add `oauth` to GmailAccountSchema\n- **Modify** `src/channel.ts` — Add `oauth` to JSON configSchema\n- **Modify** `src/gmail-client.ts` — Update factory to pass OAuth2Client to future ApiGmailClient\n\n## Acceptance Criteria\n\n- [ ] `resolveOAuthCredentials()` reads from config, falls back to gog credentials.json for client_id/secret\n- [ ] `readGogCredentials()` parses `~/.config/gogcli/credentials.json`\n- [ ] `runOAuthFlow()` opens browser, receives callback, returns refresh_token\n- [ ] `createOAuth2Client()` creates authenticated client with auto-refresh\n- [ ] `oauth` schema added to account config (Zod + JSON schema)\n- [ ] Token refresh is automatic (handled by google-auth-library)\n- [ ] No Gmail API calls yet — this is auth infrastructure only","status":"open","priority":1,"issue_type":"task","owner":"mcinteerj@gmail.com","created_at":"2026-02-22T13:21:39.544879675+13:00","created_by":"Jake McInteer","updated_at":"2026-02-22T13:21:39.544879675+13:00","labels":["auth","googleapis"],"dependencies":[{"issue_id":"gmail-2.2","depends_on_id":"gmail-2","type":"parent-child","created_at":"0001-01-01T00:00:00Z"},{"issue_id":"gmail-2.2","depends_on_id":"gmail-2.1","type":"blocks","created_at":"0001-01-01T00:00:00Z"}]}
{"id":"gmail-2.3","title":"Implement ApiGmailClient read operations","description":"## Goal\n\nImplement the read-side Gmail API operations in `ApiGmailClient` using `@googleapis/gmail`. These are the operations that don't require MIME construction.\n\n## Operations to implement\n\n### Thread operations\n\n```typescript\n// getThread — replaces gog gmail thread get <id> --full --json\nasync getThread(threadId: string, opts?: { full?: boolean }): Promise<ThreadResponse | null> {\n  const res = await this.gmail.users.threads.get({\n    userId: 'me',\n    id: threadId,\n    format: opts?.full ? 'full' : 'metadata',\n  });\n  // Map res.data to ThreadResponse format (same shape as current gog output parsing)\n}\n```\n\n### Message operations\n\n```typescript\n// getMessage — replaces gog gmail get <id>\nasync getMessage(messageId: string): Promise<GogRawMessage | null> {\n  const res = await this.gmail.users.messages.get({\n    userId: 'me',\n    id: messageId,\n    format: 'full',\n  });\n  // Map to existing GogRawMessage interface for compatibility\n}\n\n// searchMessages — replaces gog gmail messages search / gog gmail search\nasync searchMessages(query: string, maxResults?: number): Promise<{ id: string; threadId: string }[]> {\n  const res = await this.gmail.users.messages.list({\n    userId: 'me',\n    q: query,\n    maxResults: maxResults || 50,\n  });\n  return res.data.messages || [];\n}\n```\n\n### Label operations\n\n```typescript\n// listLabels — replaces gog gmail labels list\nasync listLabels(): Promise<{ id: string; name: string }[]> {\n  const res = await this.gmail.users.labels.list({ userId: 'me' });\n  return (res.data.labels || []).map(l => ({ id: l.id!, name: l.name! }));\n}\n\n// createLabel — replaces gog gmail labels create\nasync createLabel(name: string): Promise<void> {\n  await this.gmail.users.labels.create({\n    userId: 'me',\n    requestBody: { name },\n  });\n}\n```\n\n### Attachment operations\n\n```typescript\n// getAttachment — replaces gog gmail attachment <messageId> <attachmentId>\nasync getAttachment(messageId: string, attachmentId: string): Promise<Buffer> {\n  const res = await this.gmail.users.messages.attachments.get({\n    userId: 'me',\n    messageId,\n    id: attachmentId,\n  });\n  return Buffer.from(res.data.data!, 'base64url');\n}\n```\n\n### Settings operations\n\n```typescript\n// getSendAs — replaces gog gmail settings sendas list\nasync getSendAs(): Promise<{ displayName?: string; email: string; isPrimary?: boolean }[]> {\n  const res = await this.gmail.users.settings.sendAs.list({ userId: 'me' });\n  return (res.data.sendAs || []).map(s => ({\n    displayName: s.displayName || undefined,\n    email: s.sendAsEmail!,\n    isPrimary: s.isPrimary || false,\n  }));\n}\n```\n\n## Response mapping\n\nThe `@googleapis/gmail` returns typed responses that map closely but not identically to gog's JSON output. The key mapping concern is the `GogRawMessage` interface used throughout the codebase (quoting.ts, outbound-check.ts, monitor.ts). The API's `gmail_v1.Schema$Message` has the same structure (payload.headers, payload.parts, payload.body.data, labelIds, internalDate), so mapping should be straightforward.\n\nPrefer adapting the API response to match the existing `GogRawMessage` shape rather than changing all consumers. This keeps the diff small and avoids touching quoting.ts/outbound-check.ts beyond the client swap.\n\n## New Dependencies\n\n- `@googleapis/gmail` — Standalone Gmail API client (~1.2 MB)\n\n## Files to create/modify\n\n- **Create** `src/api-client.ts` — `ApiGmailClient` class implementing `GmailClient` interface (read ops)\n- **Modify** `src/gmail-client.ts` — Update factory to return `ApiGmailClient` when `backend: \"api\"`\n- **Modify** `package.json` — Add `@googleapis/gmail` dependency\n\n## Acceptance Criteria\n\n- [ ] `ApiGmailClient` implements all read methods from `GmailClient` interface\n- [ ] Response shapes match existing `GogRawMessage` / `ThreadResponse` interfaces\n- [ ] Factory returns `ApiGmailClient` when account has `backend: \"api\"` and valid OAuth credentials\n- [ ] Error handling: typed exceptions from googleapis, no stderr parsing\n- [ ] All read operations tested against a real Gmail account (manual test)","status":"open","priority":1,"issue_type":"task","owner":"mcinteerj@gmail.com","created_at":"2026-02-22T13:22:00.145344761+13:00","created_by":"Jake McInteer","updated_at":"2026-02-22T13:22:00.145344761+13:00","labels":["googleapis","api-client"],"dependencies":[{"issue_id":"gmail-2.3","depends_on_id":"gmail-2","type":"parent-child","created_at":"0001-01-01T00:00:00Z"},{"issue_id":"gmail-2.3","depends_on_id":"gmail-2.1","type":"blocks","created_at":"0001-01-01T00:00:00Z"},{"issue_id":"gmail-2.3","depends_on_id":"gmail-2.2","type":"blocks","created_at":"0001-01-01T00:00:00Z"}]}
{"id":"gmail-2.4","title":"Implement ApiGmailClient write operations and MIME construction","description":"## Goal\n\nImplement the write-side Gmail API operations: send, reply, reply-all (requiring MIME construction), and label modification.\n\n## MIME Construction with MailComposer\n\n`gmail.users.messages.send` requires a base64url-encoded RFC 2822 MIME message. Use nodemailer's MailComposer:\n\n```typescript\nimport MailComposer from 'nodemailer/lib/mail-composer';\n\nasync function buildMimeMessage(opts: {\n  from: string;\n  to: string;\n  cc?: string;\n  subject: string;\n  text: string;\n  html: string;\n  inReplyTo?: string;\n  references?: string;\n}): Promise<Buffer> {\n  const mail = new MailComposer({\n    from: opts.from,\n    to: opts.to,\n    cc: opts.cc,\n    subject: opts.subject,\n    text: opts.text,\n    html: opts.html,\n    inReplyTo: opts.inReplyTo,\n    references: opts.references,\n  });\n\n  return new Promise((resolve, reject) => {\n    mail.compile().build((err, message) => {\n      if (err) reject(err);\n      else resolve(message);\n    });\n  });\n}\n```\n\n## Operations to implement\n\n### Send (new email and reply)\n\n```typescript\nasync send(opts: {\n  from: string;\n  to: string;\n  cc?: string;\n  subject: string;\n  textBody: string;\n  htmlBody: string;\n  threadId?: string;\n  inReplyTo?: string;\n  references?: string;\n  replyAll?: boolean;\n}): Promise<{ messageId: string }> {\n  const mime = await buildMimeMessage({\n    from: opts.from,\n    to: opts.to,\n    cc: opts.cc,\n    subject: opts.subject,\n    text: opts.textBody,\n    html: opts.htmlBody,\n    inReplyTo: opts.inReplyTo,\n    references: opts.references,\n  });\n\n  const res = await this.gmail.users.messages.send({\n    userId: 'me',\n    requestBody: {\n      raw: mime.toString('base64url'),\n      threadId: opts.threadId,\n    },\n  });\n\n  return { messageId: res.data.id! };\n}\n```\n\n### Reply-All recipient resolution\n\nFor reply-all, the caller (outbound.ts) needs to determine To and Cc from the thread. This logic currently exists implicitly via gog's `--reply-all` flag. With the API client, we need to extract recipients explicitly:\n\n1. Get the last message in the thread (via `getThread`)\n2. Extract From, To, Cc headers\n3. Set `To:` = original sender (From of the message being replied to)\n4. Set `Cc:` = everyone from original To + Cc, minus self\n5. Extract `Message-ID` header for `In-Reply-To` and `References`\n\nAdd a helper method or standalone function:\n\n```typescript\nexport interface ReplyRecipients {\n  to: string;\n  cc?: string;\n  inReplyTo: string;\n  references: string;\n  subject: string;\n}\n\nasync resolveReplyRecipients(threadId: string, selfEmail: string): Promise<ReplyRecipients | null>;\n```\n\nThis replaces the need for gog's `--reply-all` and `--reply-to-message-id` flags. The outbound.ts code will call this before `send()`.\n\n### Label modification\n\n```typescript\nasync modifyLabels(messageId: string, opts: { add?: string[]; remove?: string[] }): Promise<void> {\n  await this.gmail.users.messages.modify({\n    userId: 'me',\n    id: messageId,\n    requestBody: {\n      addLabelIds: opts.add,\n      removeLabelIds: opts.remove,\n    },\n  });\n}\n\nasync modifyThreadLabels(threadId: string, opts: { add?: string[]; remove?: string[] }): Promise<void> {\n  await this.gmail.users.threads.modify({\n    userId: 'me',\n    id: threadId,\n    requestBody: {\n      addLabelIds: opts.add,\n      removeLabelIds: opts.remove,\n    },\n  });\n}\n```\n\n## New Dependencies\n\n- `nodemailer` — For MailComposer (MIME construction only, not SMTP transport)\n\n## Key differences from gog\n\n| gog flag | API equivalent |\n|----------|---------------|\n| `--reply-all` | Manually set To/Cc from thread headers |\n| `--reply-to-message-id <id>` | Set `threadId` + `In-Reply-To`/`References` MIME headers |\n| `--body-html <html>` | Pass `html` to MailComposer |\n| `--body <text>` | Pass `text` to MailComposer |\n| `--subject <subj>` | Pass `subject` to MailComposer |\n| `--account <email>` | OAuth2Client scoped to account |\n\n## Files to modify\n\n- **Modify** `src/api-client.ts` — Add `send()`, `modifyLabels()`, `modifyThreadLabels()`, `resolveReplyRecipients()`\n- **Create** `src/mime.ts` — `buildMimeMessage()` helper wrapping MailComposer\n- **Modify** `src/outbound.ts` — Update `sendGmailText()` to use `client.send()` + `client.resolveReplyRecipients()` instead of building gog args\n- **Modify** `package.json` — Add `nodemailer` dependency, add `@types/nodemailer` dev dependency\n\n## Acceptance Criteria\n\n- [ ] `send()` constructs valid RFC 2822 MIME via MailComposer and sends via API\n- [ ] Reply threading works: `threadId`, `In-Reply-To`, `References` headers correctly set\n- [ ] Reply-all correctly determines To/Cc from thread (excludes self from Cc)\n- [ ] `modifyLabels()` and `modifyThreadLabels()` work for archive (remove INBOX), mark read (remove UNREAD)\n- [ ] HTML and plain text bodies both included in multipart/alternative MIME\n- [ ] Manual test: send a reply via API client, verify it threads correctly in Gmail\n- [ ] Manual test: reply-all sends to all participants","status":"open","priority":1,"issue_type":"task","owner":"mcinteerj@gmail.com","created_at":"2026-02-22T13:22:26.966169288+13:00","created_by":"Jake McInteer","updated_at":"2026-02-22T13:22:26.966169288+13:00","labels":["googleapis","api-client","mime"],"dependencies":[{"issue_id":"gmail-2.4","depends_on_id":"gmail-2","type":"parent-child","created_at":"0001-01-01T00:00:00Z"},{"issue_id":"gmail-2.4","depends_on_id":"gmail-2.3","type":"blocks","created_at":"0001-01-01T00:00:00Z"}]}
{"id":"gmail-2.5","title":"Overhaul onboarding for googleapis and gog credential reuse","description":"## Goal\n\nUpdate the onboarding flow to support both new users (no gog) and existing gog users migrating to the API backend. The current onboarding in `src/onboarding.ts` is entirely gog-dependent (checks gog version, runs gog auth, etc.).\n\n## Onboarding Scenarios\n\n### Scenario A: Existing gog user\n\n1. Detect gog is installed and authorized for this email (`gog auth list --plain`)\n2. Detect `~/.config/gogcli/credentials.json` exists — read client_id/client_secret\n3. Prompt: \"We found your gog credentials. Migrate to direct API access? (one-time browser auth)\" \n4. If yes: run OAuth flow with gog's client_id/secret → store refresh_token in config, set `backend: \"api\"`\n5. If no: keep `backend: \"gog\"`, existing flow unchanged\n6. Continue with allowFrom, polling interval, display name (fetch via API if migrated, gog if not)\n\n### Scenario B: New user, no gog\n\n1. Detect gog is NOT installed\n2. Prompt for GCP OAuth client_id and client_secret (guide user to console.cloud.google.com)\n3. Prompt for email address\n4. Run OAuth flow → store credentials and refresh_token in config, set `backend: \"api\"`\n5. Continue with allowFrom, polling interval, display name (fetch via API)\n\n### Scenario C: New user, has gog but wants API\n\nSame as Scenario A — gog detected, offer migration.\n\n### Scenario D: Existing API user reconfiguring\n\n1. Detect existing OAuth credentials in config\n2. Skip auth flow, just update other settings\n3. Offer to re-authorize if token is expired/invalid\n\n## Key Changes to onboarding.ts\n\nThe current flow is:\n1. `checkGogInstalled()` — REQUIRED, fails if gog missing\n2. `getGogVersion()` — Version check\n3. Prompt email\n4. `checkGogAuth(email)` — Check gog auth\n5. `authorizeGog(email)` — Run `gog auth add`\n6. Prompt allowFrom, polling\n7. `fetchGmailName(email)` — Get display name via gog\n\nNew flow:\n1. Check for existing OAuth credentials in config\n2. If none: check for gog credentials file → check for gog installed\n3. Based on what's available, choose auth path (API OAuth vs gog)\n4. Prompt email\n5. Run appropriate auth flow\n6. Prompt allowFrom, polling\n7. Fetch display name (via API client or gog depending on backend)\n8. Write config with `backend: \"api\"` or `\"gog\"`\n\n**Critical**: gog is no longer a hard requirement. The `checkGogInstalled()` gate at line 100 must become conditional — only required when `backend: \"gog\"`.\n\n## Onboarding UX for GCP setup (new users without gog)\n\nNew users need to create a GCP OAuth client. Guide text:\n\n```\nTo use Gmail with OpenClaw, you need a Google Cloud OAuth client:\n1. Go to https://console.cloud.google.com/apis/credentials\n2. Create a project (or use existing)\n3. Enable the Gmail API\n4. Create OAuth 2.0 Client ID (type: Desktop app)\n5. Copy the Client ID and Client Secret\n```\n\nThis is the same setup gog requires, so the friction is equivalent.\n\n## Files to modify\n\n- **Modify** `src/onboarding.ts` — Conditional gog checks, API auth path, gog cred reuse\n- **Modify** `src/auth.ts` (from gmail-2.2) — May need helpers for credential validation\n\n## Acceptance Criteria\n\n- [ ] New user without gog can complete onboarding via OAuth (no gog dependency)\n- [ ] Existing gog user offered seamless migration with one-time browser re-auth\n- [ ] Existing gog user can decline migration and keep using gog backend\n- [ ] Client_id/client_secret read from gog's credentials.json when available\n- [ ] Display name fetched via API when using api backend, via gog when using gog backend\n- [ ] Config written with correct `backend` value\n- [ ] `gog` is no longer a hard requirement for the extension","status":"open","priority":1,"issue_type":"task","owner":"mcinteerj@gmail.com","created_at":"2026-02-22T13:22:55.796782095+13:00","created_by":"Jake McInteer","updated_at":"2026-02-22T13:22:55.796782095+13:00","labels":["onboarding","auth","googleapis"],"dependencies":[{"issue_id":"gmail-2.5","depends_on_id":"gmail-2","type":"parent-child","created_at":"0001-01-01T00:00:00Z"},{"issue_id":"gmail-2.5","depends_on_id":"gmail-2.2","type":"blocks","created_at":"0001-01-01T00:00:00Z"}]}
{"id":"gmail-3","title":"Fix channel ID mismatch preventing async outbound delivery","description":"## Problem\n\nThe plugin tags all inbound messages with \\`OriginatingChannel: \"gmail\"\\` (set in \\`src/channel.ts\\` buildGmailMsgContext and \\`src/inbound.ts\\`), so OpenClaw sessions record \\`lastChannel: \"gmail\"\\`. However, the plugin registers itself with ID \\`\"openclaw-gmail\"\\`.\n\nWhen the gateway attempts async outbound delivery (e.g. subagent completion announces), it calls \\`loadChannelOutboundAdapter(\"gmail\")\\` — which looks up plugins by their registered ID. Since no plugin is registered as \\`\"gmail\"\\`, this returns undefined and delivery **silently fails**, falling back to stale routes from other channels.\n\n## Root Cause\n\n\\`src/channel.ts\\` line 160: plugin registers as \\`id: \"openclaw-gmail\"\\`\n\\`src/channel.ts\\` line 74: inbound messages tagged \\`Provider: \"gmail\"\\`, \\`Surface: \"gmail\"\\`, \\`OriginatingChannel: \"gmail\"\\`\n\nThe gateway's \\`loadChannelOutboundAdapter()\\` resolves by registered plugin ID, not by the surface/provider strings. Sessions with \\`lastChannel: \"gmail\"\\` can't route back to \\`\"openclaw-gmail\"\\`.\n\n## Fix\n\nAdd \\`\"gmail\"\\` as an alias in the plugin's channel meta so \\`normalizeMessageChannel(\"gmail\")\\` resolves to \\`\"openclaw-gmail\"\\`:\n\nIn \\`src/channel.ts\\`, update the meta object in the \\`gmailPlugin\\` export:\n\n```typescript\nmeta: {\n  ...meta,\n  id: \"openclaw-gmail\",\n  aliases: [\"gmail\"],\n  showConfigured: true,\n},\n```\n\nThis is a plugin-side-only fix — no OpenClaw core changes needed. The \\`aliases\\` field is supported by the plugin SDK's channel resolution.\n\n## Impact\n\nWithout this fix:\n- Subagent completion results that should be delivered via Gmail are silently lost\n- Any async outbound delivery (scheduled messages, webhook-triggered replies) fails for Gmail sessions\n- Users see their agent \"not responding\" for async workflows even though the agent completed successfully\n\n## Files to modify\n\n- \\`src/channel.ts\\` — Add \\`aliases: [\"gmail\"]\\` to plugin meta\n\n## Testing\n\n1. Start a Gmail session, trigger a subagent (e.g. tool use that runs async)\n2. Verify the subagent result is delivered back to the Gmail thread\n3. Verify synchronous replies (direct inbound → dispatch → deliver) still work\n\n## Acceptance Criteria\n\n- [ ] \\`aliases: [\"gmail\"]\\` added to plugin meta in \\`channel.ts\\`\n- [ ] \\`loadChannelOutboundAdapter(\"gmail\")\\` resolves to the openclaw-gmail plugin\n- [ ] Async outbound delivery works for Gmail sessions\n- [ ] No change to synchronous reply behavior","status":"open","priority":0,"issue_type":"bug","owner":"mcinteerj@gmail.com","created_at":"2026-02-22T13:23:17.073349097+13:00","created_by":"Jake McInteer","updated_at":"2026-02-22T13:23:17.073349097+13:00","labels":["outbound","channel-id","P0"]}
